Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BCOM
    BFUNY
    BGRAM
    BPARSER
    ECOM
    EFUNY
    EGRAM
    PREC
    TS
    comm
    funY
    gram
    instructions
    preceList
    tsList

Grammar

Rule 0     S' -> Ply-Simple
Rule 1     Ply-Simple -> EOF
Rule 2     Ply-Simple -> BLEX Lex BYACC Yacc EOF
Rule 3     Ply-Simple -> BYACC Yacc BLEX Lex EOF
Rule 4     Lex -> Vars Funs
Rule 5     Lex -> <empty>
Rule 6     Vars -> Vars Var
Rule 7     Vars -> <empty>
Rule 8     Var -> LIT literals
Rule 9     Var -> IGN ig
Rule 10    Var -> TOK tokenList
Rule 11    Funs -> Funs Fun EFUNL
Rule 12    Funs -> <empty>
Rule 13    Fun -> BFUNL funL
Rule 14    Yacc -> <empty>

Terminals, with rules where they appear

BCOM                 : 
BFUNL                : 13
BFUNY                : 
BGRAM                : 
BLEX                 : 2 3
BPARSER              : 
BYACC                : 2 3
ECOM                 : 
EFUNL                : 11
EFUNY                : 
EGRAM                : 
EOF                  : 1 2 3
IGN                  : 9
LIT                  : 8
PREC                 : 
TOK                  : 10
TS                   : 
comm                 : 
error                : 
funL                 : 13
funY                 : 
gram                 : 
ig                   : 9
instructions         : 
literals             : 8
preceList            : 
tokenList            : 10
tsList               : 

Nonterminals, with rules where they appear

Fun                  : 11
Funs                 : 4 11
Lex                  : 2 3
Ply-Simple           : 0
Var                  : 6
Vars                 : 4 6
Yacc                 : 2 3

Parsing method: LALR

state 0

    (0) S' -> . Ply-Simple
    (1) Ply-Simple -> . EOF
    (2) Ply-Simple -> . BLEX Lex BYACC Yacc EOF
    (3) Ply-Simple -> . BYACC Yacc BLEX Lex EOF

    EOF             shift and go to state 2
    BLEX            shift and go to state 3
    BYACC           shift and go to state 4

    Ply-Simple                     shift and go to state 1

state 1

    (0) S' -> Ply-Simple .



state 2

    (1) Ply-Simple -> EOF .

    $end            reduce using rule 1 (Ply-Simple -> EOF .)


state 3

    (2) Ply-Simple -> BLEX . Lex BYACC Yacc EOF
    (4) Lex -> . Vars Funs
    (5) Lex -> .
    (6) Vars -> . Vars Var
    (7) Vars -> .

  ! reduce/reduce conflict for BYACC resolved using rule 5 (Lex -> .)
    BYACC           reduce using rule 5 (Lex -> .)
    LIT             reduce using rule 7 (Vars -> .)
    IGN             reduce using rule 7 (Vars -> .)
    TOK             reduce using rule 7 (Vars -> .)
    BFUNL           reduce using rule 7 (Vars -> .)

  ! BYACC           [ reduce using rule 7 (Vars -> .) ]

    Lex                            shift and go to state 5
    Vars                           shift and go to state 6

state 4

    (3) Ply-Simple -> BYACC . Yacc BLEX Lex EOF
    (14) Yacc -> .

    BLEX            reduce using rule 14 (Yacc -> .)

    Yacc                           shift and go to state 7

state 5

    (2) Ply-Simple -> BLEX Lex . BYACC Yacc EOF

    BYACC           shift and go to state 8


state 6

    (4) Lex -> Vars . Funs
    (6) Vars -> Vars . Var
    (11) Funs -> . Funs Fun EFUNL
    (12) Funs -> .
    (8) Var -> . LIT literals
    (9) Var -> . IGN ig
    (10) Var -> . TOK tokenList

    BFUNL           reduce using rule 12 (Funs -> .)
    BYACC           reduce using rule 12 (Funs -> .)
    EOF             reduce using rule 12 (Funs -> .)
    LIT             shift and go to state 11
    IGN             shift and go to state 12
    TOK             shift and go to state 13

    Funs                           shift and go to state 9
    Var                            shift and go to state 10

state 7

    (3) Ply-Simple -> BYACC Yacc . BLEX Lex EOF

    BLEX            shift and go to state 14


state 8

    (2) Ply-Simple -> BLEX Lex BYACC . Yacc EOF
    (14) Yacc -> .

    EOF             reduce using rule 14 (Yacc -> .)

    Yacc                           shift and go to state 15

state 9

    (4) Lex -> Vars Funs .
    (11) Funs -> Funs . Fun EFUNL
    (13) Fun -> . BFUNL funL

    BYACC           reduce using rule 4 (Lex -> Vars Funs .)
    EOF             reduce using rule 4 (Lex -> Vars Funs .)
    BFUNL           shift and go to state 17

    Fun                            shift and go to state 16

state 10

    (6) Vars -> Vars Var .

    LIT             reduce using rule 6 (Vars -> Vars Var .)
    IGN             reduce using rule 6 (Vars -> Vars Var .)
    TOK             reduce using rule 6 (Vars -> Vars Var .)
    BFUNL           reduce using rule 6 (Vars -> Vars Var .)
    BYACC           reduce using rule 6 (Vars -> Vars Var .)
    EOF             reduce using rule 6 (Vars -> Vars Var .)


state 11

    (8) Var -> LIT . literals

    literals        shift and go to state 18


state 12

    (9) Var -> IGN . ig

    ig              shift and go to state 19


state 13

    (10) Var -> TOK . tokenList

    tokenList       shift and go to state 20


state 14

    (3) Ply-Simple -> BYACC Yacc BLEX . Lex EOF
    (4) Lex -> . Vars Funs
    (5) Lex -> .
    (6) Vars -> . Vars Var
    (7) Vars -> .

  ! reduce/reduce conflict for EOF resolved using rule 5 (Lex -> .)
    EOF             reduce using rule 5 (Lex -> .)
    LIT             reduce using rule 7 (Vars -> .)
    IGN             reduce using rule 7 (Vars -> .)
    TOK             reduce using rule 7 (Vars -> .)
    BFUNL           reduce using rule 7 (Vars -> .)

  ! EOF             [ reduce using rule 7 (Vars -> .) ]

    Lex                            shift and go to state 21
    Vars                           shift and go to state 6

state 15

    (2) Ply-Simple -> BLEX Lex BYACC Yacc . EOF

    EOF             shift and go to state 22


state 16

    (11) Funs -> Funs Fun . EFUNL

    EFUNL           shift and go to state 23


state 17

    (13) Fun -> BFUNL . funL

    funL            shift and go to state 24


state 18

    (8) Var -> LIT literals .

    LIT             reduce using rule 8 (Var -> LIT literals .)
    IGN             reduce using rule 8 (Var -> LIT literals .)
    TOK             reduce using rule 8 (Var -> LIT literals .)
    BFUNL           reduce using rule 8 (Var -> LIT literals .)
    BYACC           reduce using rule 8 (Var -> LIT literals .)
    EOF             reduce using rule 8 (Var -> LIT literals .)


state 19

    (9) Var -> IGN ig .

    LIT             reduce using rule 9 (Var -> IGN ig .)
    IGN             reduce using rule 9 (Var -> IGN ig .)
    TOK             reduce using rule 9 (Var -> IGN ig .)
    BFUNL           reduce using rule 9 (Var -> IGN ig .)
    BYACC           reduce using rule 9 (Var -> IGN ig .)
    EOF             reduce using rule 9 (Var -> IGN ig .)


state 20

    (10) Var -> TOK tokenList .

    LIT             reduce using rule 10 (Var -> TOK tokenList .)
    IGN             reduce using rule 10 (Var -> TOK tokenList .)
    TOK             reduce using rule 10 (Var -> TOK tokenList .)
    BFUNL           reduce using rule 10 (Var -> TOK tokenList .)
    BYACC           reduce using rule 10 (Var -> TOK tokenList .)
    EOF             reduce using rule 10 (Var -> TOK tokenList .)


state 21

    (3) Ply-Simple -> BYACC Yacc BLEX Lex . EOF

    EOF             shift and go to state 25


state 22

    (2) Ply-Simple -> BLEX Lex BYACC Yacc EOF .

    $end            reduce using rule 2 (Ply-Simple -> BLEX Lex BYACC Yacc EOF .)


state 23

    (11) Funs -> Funs Fun EFUNL .

    BFUNL           reduce using rule 11 (Funs -> Funs Fun EFUNL .)
    BYACC           reduce using rule 11 (Funs -> Funs Fun EFUNL .)
    EOF             reduce using rule 11 (Funs -> Funs Fun EFUNL .)


state 24

    (13) Fun -> BFUNL funL .

    EFUNL           reduce using rule 13 (Fun -> BFUNL funL .)


state 25

    (3) Ply-Simple -> BYACC Yacc BLEX Lex EOF .

    $end            reduce using rule 3 (Ply-Simple -> BYACC Yacc BLEX Lex EOF .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 3 resolved using rule (Lex -> <empty>)
WARNING: rejected rule (Vars -> <empty>) in state 3
WARNING: reduce/reduce conflict in state 14 resolved using rule (Lex -> <empty>)
WARNING: rejected rule (Vars -> <empty>) in state 14
